{"pageProps":{"note":{"id":"x26u7mxd81wcam73qz7b0gk","title":"用 JSONP 实现跨域 AJAX 请求","desc":"","updated":1677378013768,"created":1677377967041,"custom":{},"fname":"20181116-用JSONP实现跨域AJAX请求","type":"note","vault":{"fsPath":"vault","name":"vault"},"contentHash":"a1d280c6cb2652f12c49a2322386c772","links":[],"anchors":{"如何用-jsonp-实现跨域请求":{"type":"header","text":"如何用 JSONP 实现跨域请求","value":"如何用-jsonp-实现跨域请求","line":17,"column":0,"depth":3},"具体实现":{"type":"header","text":"具体实现","value":"具体实现","line":29,"column":0,"depth":4}},"children":[],"parent":"9ulx2r70mqzuktc8d2y4dqt","data":{}},"body":"<h1 id=\"用-jsonp-实现跨域-ajax-请求\">用 JSONP 实现跨域 AJAX 请求<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#用-jsonp-实现跨域-ajax-请求\"></a></h1>\n<blockquote>\n<p>写于：2018-11-16</p>\n</blockquote>\n<p>互联网的同源政策避免了很多安全问题，但是在限制作恶的同时也造成一些不便，比如你想要向自己的服务器发送 AJAX 请求时，却被告知跨域而禁止执行。比如某家大型公司（比如维基百科）有多个子域名：</p>\n<blockquote>\n<ul>\n<li>wikipedia.com</li>\n<li>en.wikipedia.com</li>\n<li>cn.wikipedia.com</li>\n<li>它们之间无法进行数据交换，带来了很多不便。如今，为了满足合法的跨域数据交换需求已经有多个方案，最为常用包括 JSONP、CORS 等，今天下先介绍一下 JSONP。</li>\n</ul>\n</blockquote>\n<h3 id=\"如何用-jsonp-实现跨域请求\">如何用 JSONP 实现跨域请求<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#如何用-jsonp-实现跨域请求\"></a></h3>\n<p>JSONP 全称——JavaScript Object Notation with Padding 填充式 JSON。JSONP 并不是一种文件格式，而不过是一种对跨域的实现方式的称呼，实际上使用的就是 JSON 格式。\nHTML 中 script 元素，可以加载来自“不同源”主机的代码，例如：引入 Vue 框架的 js 文件，尽管脚本文件来自不同源的主机，我们的电脑也一样可以将其下载到本地之后执行：</p>\n<pre><code>&#x3C;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\">&#x3C;script>\n</code></pre>\n<p>JSONP 就是利用了 script 元素这一特点：服务器将一段 JS 代码使用字符串的方式“填充”在 JSON 对象中，客户端网页中的 script 元素在收到 JSON 文件后将其解析并立即执行。\n上面解释了如何实现跨域传递代码，其实这样就不难理解如何把数据放在代码中一并传递了，其实是在代码中使用了客户端定义好的函数的调用，并在函数调用体内添加了相关数据。下面看看具体的实现步骤。</p>\n<h4 id=\"具体实现\">具体实现<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#具体实现\"></a></h4>\n<p>比如客户端、服务器都在本地但是端口号不同，受到同源政策的限制客户端无法向服务器实现跨域请求：</p>\n<blockquote>\n<p>客户端：http://localhost:80\n服务器：http://localhost:3000\n1）客户端做好接收数据准备\n在 script 标签中或者 JS 文件中，定义函数 myCallbackFuntion，赋予形参 data。</p>\n</blockquote>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">myCallback</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">data</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">var</span> h1 <span class=\"token operator\">=</span> <span class=\"token dom variable\">document</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'h1'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//创建h1标签用于显示数据</span>\n\th1<span class=\"token punctuation\">.</span><span class=\"token property-access\">innerHTML</span> <span class=\"token operator\">=</span> data<span class=\"token punctuation\">.</span><span class=\"token property-access\">response</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//将数据添加至h1标签内部</span>\n\t<span class=\"token dom variable\">document</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">body</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">appendChild</span><span class=\"token punctuation\">(</span>h1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//将h1标签添加到body中</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p>2）服务器端准备好数据\n这里用 PHP 作为示例，客户端请求的 PHP 文件 user.php 中加入 header，标识所传输的数据为一段 JS 代码：</p>\n<pre><code>header(\"Content-Type:application/javascript\")\n</code></pre>\n<p>在 user.php 中接收并储存客户端自定义的函数名：</p>\n<pre class=\"language-js\"><code class=\"language-js\">$callback <span class=\"token operator\">=</span> $_REQUEST<span class=\"token punctuation\">[</span><span class=\"token string\">'callback'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>定义<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mtext>表示储存需要返回的数据：</mtext></mrow><annotation encoding=\"application/x-tex\">data表示储存需要返回的数据：</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">a</span><span class=\"mord cjk_fallback\">表示储存需要返回的数据：</span></span></span></span></span>data=[\"response\":\"hello world from JSONP!\"];\n拼接字符串，将数据作为参数放在函数调用体内部，将拼接好的字符串返回客户端：\necho \"<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>c</mi><mi>a</mi><mi>l</mi><mi>l</mi><mi>b</mi><mi>a</mi><mi>c</mi><mi>k</mi><mo stretchy=\"false\">(</mo></mrow><annotation encoding=\"application/x-tex\">callback(</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">ll</span><span class=\"mord mathnormal\">ba</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mopen\">(</span></span></span></span></span>data)\";\n3）客户端发送请求并接收响应\n创建一个 script 标签（src=目标主机上请求 URL），在请求 URL 后附上上面定义好的函数名称：</p>\n<pre class=\"language-html\"><code class=\"language-html\">&#x3C;script src=\"http://localhost/user.php:3000?callback=myCallback”>\n</code></pre>\n<p>当 HTML 页面刷新时，浏览器会解析该 script 标签并发送 GET 请求：</p>\n<pre class=\"language-sh\"><code class=\"language-sh\">GET /?callback=myCallback HTTP/1.1\n</code></pre>\n<p>当接收到服务器端响应——并非普通 JSON 而是一段 JS 代码：\nmyCallbackFuntion({\"response\": \"hello world from JSONP!\"})\n形成了对 myCallbackFunction 函数的调用，并传入了服务器定义的数据作为参数，最终实现了客户端与服务器端的跨域数据传递——服务器端将数据返回客户端，客户端使用数据进行页面渲染见。\n总结：\n使用 JSONP 实现跨域请求，是通过借由 script 元素（无论是在 HTML 中或者通过 JS 动态添加）通过浏览器发起 GET 请求实现的，如果你需要用到其他 HTTP 请求（比如：POST），则无法使用 JSONP 方法。\n补充：\n第 3 步的 script 标签只用来发送跨域请求，在 HTML 页面中会显得累赘，最好用后即弃，因此尽量使用 JS 代码动态创建 script，并在请求执行完成后进行移除，具体做法如下：</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 将跨域请求封装成函数</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">crossOriginRequest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">var</span> script <span class=\"token operator\">=</span> <span class=\"token dom variable\">document</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'script'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//创建script元素并添加scr属性</span>\n\tscript<span class=\"token punctuation\">.</span><span class=\"token property-access\">src</span> <span class=\"token operator\">=</span> <span class=\"token string\">'http://localhost/user.php:3000?callback=myCallback'</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token dom variable\">document</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">body</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">appendChild</span><span class=\"token punctuation\">(</span>script<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//在body尾部加入元素</span>\n\t<span class=\"token keyword\">var</span> lastScript <span class=\"token operator\">=</span> <span class=\"token dom variable\">document</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">body</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'script:last-child'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">//获取最后添加的script元素</span>\n\t<span class=\"token dom variable\">document</span><span class=\"token punctuation\">.</span><span class=\"token property-access\">body</span><span class=\"token punctuation\">.</span><span class=\"token method function property-access\">removeChild</span><span class=\"token punctuation\">(</span>lastScript<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//移除body尾部的script元素</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 在页面加载时调用跨域请求函数</span>\n<span class=\"token dom variable\">window</span><span class=\"token punctuation\">.</span><span class=\"token method-variable function-variable method function property-access\">onload</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">crossOriginRequest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<ol>\n<li>AJAX-Asynchronous JavaScript And XML（异步 JavaScript 和 XML），一种 web 技术的统称，客户端异步的向服务器端发送请求并从服务器端获取数据。</li>\n</ol>","noteIndex":{"id":"9ulx2r70mqzuktc8d2y4dqt","title":"Root","desc":"","updated":1677372670607,"created":1677372670607,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":"vault","name":"vault"},"contentHash":"d1b3b549bffbc9406db1ab2a62f7532a","links":[],"anchors":{"welcome-to-dendron":{"type":"header","text":"Welcome to Dendron","value":"welcome-to-dendron","line":7,"column":0,"depth":1},"lookup":{"type":"header","text":"Lookup","value":"lookup","line":11,"column":0,"depth":2}},"children":["06npfpt8dfn6bek5i4ot77o","2qgkc58zn6cl7flma4g7msu","di3ufysjttt06q6allkds6y","n140devp4qgpdzgu03kp2a4","3iezwurw0dx7qo5zfgjqrqi","namt3sv2t4my5y07vzlqhf3","x26u7mxd81wcam73qz7b0gk","h1fu09ilp1qb1ljhczwg7n7","i1nu3sxndp3cuo3lwzuz203","b50kz068s83h4oubvlxogkw"],"parent":null,"data":{},"body":"# Welcome to Dendron\n\nThis is the root of your dendron vault. If you decide to publish your entire vault, this will be your landing page. You are free to customize any part of this page except the frontmatter on top.\n\n## Lookup\n\nThis section contains useful links to related resources.\n\n- [Getting Started Guide](https://link.dendron.so/6b25)\n- [Discord](https://link.dendron.so/6b23)\n- [Home Page](https://wiki.dendron.so/)\n- [Github](https://link.dendron.so/6b24)\n- [Developer Docs](https://docs.dendron.so/)"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":false,"leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2,"vaultSelectionModeOnCreate":"smart"}},"randomNote":{},"insertNote":{"initialValue":"templates"},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":"vault","name":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link","taskCompleteStatus":["done","x"]},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":true,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"dendronVersion":"0.85.0","enableFullHierarchyNoteTitle":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false,"enableFrontmatterTags":true,"enableHashesForFMTags":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Yinan Zhao's Blog","description":"个人博客"},"github":{"enableEditLink":true,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"lookup","siteUrl":"https://onezhaoyn.github.io","hierarchyDisplayTitle":"子集文章","duplicateNoteBehavior":{"action":"useVault","payload":["vault"]},"siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true}