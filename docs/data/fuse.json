{"keys":[{"path":["title"],"id":"title","weight":1,"src":"title","getFn":null},{"path":["body"],"id":"body","weight":1,"src":"body","getFn":null}],"records":[{"i":0,"$":{"0":{"v":"This page has not yet sprouted","n":0.408},"1":{"v":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","n":0.189}}},{"i":1,"$":{"0":{"v":"Root","n":1},"1":{"v":"# Welcome to Dendron\n\nThis is the root of your dendron vault. If you decide to publish your entire vault, this will be your landing page. You are free to customize any part of this page except the frontmatter on top.\n\n## Lookup\n\nThis section contains useful links to related resources.\n\n- [Getting Started Guide](https://link.dendron.so/6b25)\n- [Discord](https://link.dendron.so/6b23)\n- [Home Page](https://wiki.dendron.so/)\n- [Github](https://link.dendron.so/6b24)\n- [Developer Docs](https://docs.dendron.so/)","n":0.132}}},{"i":2,"$":{"0":{"v":"我是如何调整番茄工作法的——别让你的番茄太碎片化","n":1},"1":{"v":"\n> 写于：2020-08-16\n\n![](/assets/images/2023-02-26-10-22-53.jpg)\n\n不断想办法提高自己的工作、学习效能的我们，很容易会接触到“番茄工作法”。它的简单易行，广为被人们所接受。然而，在用了两年多以后，我发现它可能并不适合我。\n\n## 经验\n\n差不多 2 年前，我从一个微信群里了解到了番茄工作法，后来便让自己用上了，在工作中和学习上立即用上了。\n\n它上手简单、可操作性极强，一定程度上可以提升做事情的效率。一直到现在，都在断断续续的用着，多的时候一天能有 10+个番茄（25 分钟/番茄）。\n\n然而用到现在，我发现了一个问题：由于一个番茄只有 25 分钟，刚刚要进入专注状态了，就被休息的 5 分钟时间给打断了，如同强行被打断，而且 5 分钟之后才能继续干刚才的事情。\n\n这又引出了一连串问题：\n\n1. 休息后很容易从 5 分钟扩大到 15 分钟甚至更长；\n2. 25 分钟过于碎片化，也意味着和心流体验（非常专注的状态）彻底无缘；\n3. 由于无法长时间专注，因此很难和知识、事情建立起强连接；\n\n这就非常有问题了，用了番茄工作法，说不定效率还不如不用的人呢。\n\n很庆幸自己能发现这一点，也为这两年多自己的效率感到惋惜：为何到现在才发现番茄工作法问题呢？主要还是没有反思，不注重自身体验。\n\n## 我的反思\n\n我认为以 25 分钟为单位最大的缺点就是他会把你的时间碎片化，同时也会把你的注意力碎片化。可能让你无法长时间的专注一项工作，反而会主动分散你的注意力，无法让人进入专注的状态，也无法体会到心流体验。\n\n偶然一次在 YouTube，看了一个英国大三的医学院学生 [Kharma Medic](https://www.youtube.com/watch?v=3NSkk31vFbU) 的视频。他每天学习 8 小时，他的学习方式很特别：上午 4 小时、下午 4 小时，每 1 小时之间有短暂休息，一天下来效率不错，完善还给自己留出了玩游戏和追剧的时间。\n\nKharma Medic 总结这种学习方式的优点：\n\n- 最大化产出效率\n- 尽可能减少休息\n- 增加自由时间\n\n他还总结了如何做到如此长时间坚持的诀窍：\n\n- 提前一天晚上做好第二天的计划\n- 减少起身次数（起身容易让自己分心，起码一小时后再起身）\n- 把手机藏起来\n- 给自己奖励（游戏、朋友玩、吃喝）\n\n## 改进方案\n\n看完 Kharma Medic 的视频，我立刻意识到这才是更好的工作/学习方法，原来的 25 分钟番茄太过于碎片化了。\n\n你可能会说，一个番茄 25 分钟，我一天搞 10 个番茄不也 5 个小时时间了吗，也很可观么？\n\n其实不然，我认为无论工作和学习，我们首先都应该把高效放在首位，就是千万不要“野蛮”的靠堆时间来衡量自己的产出，工作加班的道理也是一样的（见[加班与效率](https://coolshell.cn/articles/10217.html)）。\n\n时长因素固然重要，但是却并不是最重要的。无论工作还是学习，最重要的是这段时间你所能创造的价值。所以做事情的时间不是越长越好，而是要提高单位时间内做事情的质量。\n\n在我看来，学习或工作中，越是专注，就越能和知识建立强连接，无形当中你的学习、工作能力都有所增强。\n\n因此我认为：`专注的价值>工作时长`，所以我决定把一个番茄的时间调整到 1 小时，因为 25 分钟和 1 小时所能带来的专注程度完全不同。\n\n所以现在我基本上会每工作 1 小时再起身休息一下，应该会对于我的个人学习、工作有所影响。\n","n":0.124}}},{"i":3,"$":{"0":{"v":"为什么写作是最好的投资","n":1},"1":{"v":"\n> 写于：2019-10-04\n\n![](/assets/images/2023-02-26-10-22-18.png)\n\n## 1.写作免费\n\n写作可以在纸上、手机上、电脑上，都可以进行，你需要付出的只不过是自己的一些脑力和时间，然而获得的回报可能是非常大的。\n然而写作最终会带来什么收益呢？写作带来的收益可能是极大的，然而到底能带来哪些收益呢，我只能用我有限的思考逻辑来总结这些优点。\n\n## 2.写作收益——思考能力\n\n写作所能带来的最大的收益，就是思考能力。\n我一直都有一个观点，一个人最终所能否有所发展，其中一个决定性因素就是他是否具备一定的思考能力。因为一个不会思考的人，意味着他没有想法，没有想法意味着他不过“泯然众人矣”。\n写作其实就是一个人思考，只不过将这些思考整理成了文字，这么一说其实写作顿发高大上了许多。在下笔的过程中会不断刺激个人的思考，会不断的涌现出更多的思考，思考的带宽和速度得以加强。\n当你成为一个懂得思考的人以后，你一定会创造非凡的人生，最起码是与众不同的人生。\n思考方式有很多种，然后最好的方式可能就是写作。为什么这么说，因为如果只是在脑子里想，很容易想着想着就跑偏了，或者想法非常零碎不成体系。\n然而通过把思考记录下来，不仅有利于你缕清思绪，同时可以作为思考记录，下一次可以以之前的思考为基础或者论据进行，这样你的思考就有了层次，甚至有可能触及更深刻的内容。\n再者，通过阅读自己写的东西，你可以思考自己的思考，过滤掉一些思考废渣，弥补自己思考的漏洞，从而让自己的思考更加的缜密和周全。\n\n## 3.写作收益——带来的机会\n\n在如今的互联网时代，写作应该是让自己与互联网这一“超级母体”沟通的途径之一。通过在世界上发生，你可以让世界上任何一个人，轻触屏幕即可了解你之所想，还有什么比这个更梦幻的吗？\n这项被称之为写作的活动，极大的减小了信息从你的脑中传入其他人大脑的消耗，甚至是最具效率的信息传播途径。\n然而你通过这项活动，也让自己的大脑跟这个互联网连接上了，你再写作过程中也会阅读其他人的思考的结晶，吸纳其中的营养舍弃不好的，这样就形成了跟互联网这个巨大母体的交融和交流。\n你留下在互联网上的内容绝对不会是白费的，因为可能日后真的会成为别人发现你的一个入口之一。\n\n## 4.写作收益——人生规划\n\n写作其实是带着问题去进行的，比如对于自己的前途存在一定的迷茫，在写作过程中其实也会慢慢的清晰，对自己想要从事的事情应该也会渐渐明了。对于自己人生规划也会最终水落石出。\n\n## 5.写作前的准备\n\n- 提高打字速度：让自己的打字速度跟上自己思考速度，推荐用双拼输入法，极大提高自己输入效率\n- 写作注重速度还是质量：速度优先，保证输出频率，比如：一周一篇文章，写的越快你才会更愿意写，才能把这项活动坚持下来\n- 写作习惯：每天保持写作习惯，把想法或者思考记录下来\n- 写作工具：手机端——SimpleNote，PC 端写作——VS Code，梳理文章大纲——幕布，保存发表的文章——印象笔记\n","n":0.277}}},{"i":4,"$":{"0":{"v":"如何使用VSCode快速创建单文件vue模板","n":1},"1":{"v":"\n> 写于：2019-04-03\n\n![](/assets/images/2023-02-26-10-21-04.png)\n\n用 VS Code 写 HTML 网页时，只需按下`!`键，即可一键快速输入 HTML 基础模板，很享受这种便捷。\n然而在写 Vue 的时候，试了几次都没找到快速输入 vue 模板方法。虽然单文件组件内容不多，但是组件多啊，这种不满一直不断累积。\n直到前一阵子，是在无法忍受了，受不了这种效率底下的感受，经过一番折腾找到了解决方案，下面说说怎么做到的。\n大致流程如下：\n\n1. 创建新的 Vue 代码片段（snippet）\n2. 自定义 Vue 模板，并设置代码片段识别符（类似指令，让编辑器知道你想要插入一个预设的代码片段）\n3. 在 vue 文件中输入识别符，VS Code 会自动弹出菜单，按`回车`键快速插入\n\n## 1. 创建 Vue 代码片段\n\n打开 VS Code“用户代码片段”（User snippets），截图是 Mac 端举例，Windows 端也类似。\n\n![](/assets/images/2023-02-26-10-21-11.png)\n\n选择“vue (Vue)”，表示自定义.vue 文件的代码片段。\n\n![](/assets/images/2023-02-26-10-21-16.png)\n\n之后会进入到`vue.json`的编辑界面，JSON 文件中所填写的内容，会根据用户需求插入文档中。\n\n## 2. 自定义 Vue 模板\n\n根据个人经验，如下几点：\n\n- 所有代码片段都只在`.vue`文件中才生效\n- 一个代码片段对应 JSON 对象的一个属性\n- 单个代码片段自身也是一个 JSON 对象，包含`prefix`、`body`、`description`等属性\n  代码片段的语法也很简单：\n- `prefix`表示识别符（前缀），编辑器会根据识别符的输入插入代码片段`body`中的内容\n- `body`表示最终插入到文档中的代码内容\n- `description`是注释，便于日后翻看和维护\n- `$1`和`$2`等是指插入代码片段以后，光标在代码中停留的位置，按`TAB`切换位置，\\$0 是指光标最终停留的位置。还可设置默认占位的内容，语法为：`${1:label}`。\n\n![](/assets/images/2023-02-26-10-21-22.png)\n\n## 3. 实现快速输入自定义 vue 模板内容\n\n创建`.vue`文件，输入预设的识别符`prefix`字段对应的内容（我设置的`!vue`），会弹出提示，按下回车即可插入自定义的模板内容，简直爽歪歪，很享受高效的感觉，相信之后再创建 vue 单文件组件只会是一种享受，而不是一种难受。\n\n![](/assets/images/2023-02-26-10-21-30.png)\n\n![](/assets/images/2023-02-26-10-21-35.png)\n\n看来编程还是需要不断提高生产力，才会感受到快乐，哈哈。\n","n":0.129}}},{"i":5,"$":{"0":{"v":"用 JSONP 实现跨域 AJAX 请求","n":0.447},"1":{"v":"\n> 写于：2018-11-16\n\n互联网的同源政策避免了很多安全问题，但是在限制作恶的同时也造成一些不便，比如你想要向自己的服务器发送 AJAX 请求时，却被告知跨域而禁止执行。比如某家大型公司（比如维基百科）有多个子域名：\n\n> - wikipedia.com\n> - en.wikipedia.com\n> - cn.wikipedia.com\n> - 它们之间无法进行数据交换，带来了很多不便。如今，为了满足合法的跨域数据交换需求已经有多个方案，最为常用包括 JSONP、CORS 等，今天下先介绍一下 JSONP。\n\n### 如何用 JSONP 实现跨域请求\n\nJSONP 全称——JavaScript Object Notation with Padding 填充式 JSON。JSONP 并不是一种文件格式，而不过是一种对跨域的实现方式的称呼，实际上使用的就是 JSON 格式。\nHTML 中 script 元素，可以加载来自“不同源”主机的代码，例如：引入 Vue 框架的 js 文件，尽管脚本文件来自不同源的主机，我们的电脑也一样可以将其下载到本地之后执行：\n\n```\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"><script>\n```\n\nJSONP 就是利用了 script 元素这一特点：服务器将一段 JS 代码使用字符串的方式“填充”在 JSON 对象中，客户端网页中的 script 元素在收到 JSON 文件后将其解析并立即执行。\n上面解释了如何实现跨域传递代码，其实这样就不难理解如何把数据放在代码中一并传递了，其实是在代码中使用了客户端定义好的函数的调用，并在函数调用体内添加了相关数据。下面看看具体的实现步骤。\n\n#### 具体实现\n\n比如客户端、服务器都在本地但是端口号不同，受到同源政策的限制客户端无法向服务器实现跨域请求：\n\n> 客户端：http://localhost:80\n> 服务器：http://localhost:3000\n> 1）客户端做好接收数据准备\n> 在 script 标签中或者 JS 文件中，定义函数 myCallbackFuntion，赋予形参 data。\n\n```js\nfunction myCallback(data) {\n\tvar h1 = document.createElement('h1'); //创建h1标签用于显示数据\n\th1.innerHTML = data.response; //将数据添加至h1标签内部\n\tdocument.body.appendChild(h1); //将h1标签添加到body中\n}\n```\n\n2）服务器端准备好数据\n这里用 PHP 作为示例，客户端请求的 PHP 文件 user.php 中加入 header，标识所传输的数据为一段 JS 代码：\n\n```\nheader(\"Content-Type:application/javascript\")\n```\n\n在 user.php 中接收并储存客户端自定义的函数名：\n\n```js\n$callback = $_REQUEST['callback'];\n```\n\n定义$data表示储存需要返回的数据：\n$data=[\"response\":\"hello world from JSONP!\"];\n拼接字符串，将数据作为参数放在函数调用体内部，将拼接好的字符串返回客户端：\necho \"$callback($data)\";\n3）客户端发送请求并接收响应\n创建一个 script 标签（src=目标主机上请求 URL），在请求 URL 后附上上面定义好的函数名称：\n\n```html\n<script src=\"http://localhost/user.php:3000?callback=myCallback”>\n```\n\n当 HTML 页面刷新时，浏览器会解析该 script 标签并发送 GET 请求：\n\n```sh\nGET /?callback=myCallback HTTP/1.1\n```\n\n当接收到服务器端响应——并非普通 JSON 而是一段 JS 代码：\nmyCallbackFuntion({\"response\": \"hello world from JSONP!\"})\n形成了对 myCallbackFunction 函数的调用，并传入了服务器定义的数据作为参数，最终实现了客户端与服务器端的跨域数据传递——服务器端将数据返回客户端，客户端使用数据进行页面渲染见。\n总结：\n使用 JSONP 实现跨域请求，是通过借由 script 元素（无论是在 HTML 中或者通过 JS 动态添加）通过浏览器发起 GET 请求实现的，如果你需要用到其他 HTTP 请求（比如：POST），则无法使用 JSONP 方法。\n补充：\n第 3 步的 script 标签只用来发送跨域请求，在 HTML 页面中会显得累赘，最好用后即弃，因此尽量使用 JS 代码动态创建 script，并在请求执行完成后进行移除，具体做法如下：\n\n```js\n// 将跨域请求封装成函数\nfunction crossOriginRequest() {\n\tvar script = document.createElement('script'); //创建script元素并添加scr属性\n\tscript.src = 'http://localhost/user.php:3000?callback=myCallback';\n\tdocument.body.appendChild(script); //在body尾部加入元素\n\tvar lastScript = document.body.querySelector('script:last-child');\n\t//获取最后添加的script元素\n\tdocument.body.removeChild(lastScript); //移除body尾部的script元素\n}\n\n// 在页面加载时调用跨域请求函数\nwindow.onload = function () {\n\tcrossOriginRequest();\n};\n```\n\n1. AJAX-Asynchronous JavaScript And XML（异步 JavaScript 和 XML），一种 web 技术的统称，客户端异步的向服务器端发送请求并从服务器端获取数据。\n","n":0.079}}},{"i":6,"$":{"0":{"v":"跨域是什么？","n":1},"1":{"v":"\n> 写于：2018-11-09\n\n在当你再向另一主机上的文件发送 HTTP 请求时，浏览器会在 Console 里提示如下：\n\n```\nXMLHttpRequest cannot load http://xxx.xxx. No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://my.app' is therefore not allowed access.\n```\n\n提示你当前的行为属于**跨域访问**，出于对网络安全的考量这种类型的访问是被严格禁止的。\n\n#### 什么是跨域？\n\n跨域，其实是指访问了或读取了储存在**不同源的地址**（详见下方文字）下的文件，比如读取 cookie、向其发送 HTTP 请求获取其返回的数据等等。而这种访问其实违反了互联网的安全基石：**同源政策 Same-origin policy**。\n同源政策于 1995 年由网景公司提出，该政策最初是为了避免非法获取和操控 DOM 对象（Document Object Model 文档对象模型），而今已拓展到对于全局 JavaScript 对象的保护。\n要弄清楚跨域，看来有必要先了解“同源”(Same origin)是什么，同源有 3 个要素，即：\n\n```\n**同协议、同域名、同端口**\n```\n\n我们平时上网输入的百度网址 www.baidu.com，其实只是网址全称的一部分，即**域名**，**协议**包含：http 超文本传输协议和 https 超文本传输安全协议，**端口号**最常用的是 80 端口，该端口为默认端口一般省略不写。拿百度的网址全名做例子：[https://ws3.sinaimg.cn/large/006tNbRwly1fwz7cguhqmj304x00vjra.jpg]\n\n```\n协议：http\n域名：www.baidu.com\n端口：80（默认端口号，可省）\n```\n\n上述 3 个要素只要变一个就被不“同源”或跨域，违反了同源政策，比如：\n\n```\nhttps://www.baidu.com:80\nhttp://baidu.com:80\nhttp://www.baidu.com:81\n```\n\n而以下的网址使用的是同一协议（http）、域名（www.baidu.com）、和端口（80）则符合同源，不被视作跨域：\n\n```\nhttp://www.baidu.com/1.html\nhttp:///www.baidu.com/dir/2.html\n```\n\n### 为什么禁止跨域访问？\n\n同源政策禁止跨域访问，该政策被视作互联网安全的基石，所有的现代浏览器都遵守该政策，禁止跨域访问。\n跨域访问哪儿妨碍了互联网安全了呢？\n其实最关键的是，跨域访问可以通过访问不同网站保存在本地的 cookie，而在 cookie 中保存了敏感信息，比如用户登录信息，一旦 cookie 被访问/操纵，意味着第三方能够以用户本人的身份自由的与服务器通信（服务器根本不知道用户数据被盗），因此第三方自由进入你的网银账户，试想：如果有人冒充你本人，去银行转账/查询所有交易记录，或者直接挂失/销户，你是什么感觉？\n因此，跨域访问所防范的，其实是恶意网站上的恶意代码，通过其他网站保存在本地的文件（包括 cookie），非法获取用户信息/数据。\n现在应该能明白为什么同源政策是互联网安全的基石了：一旦不同源网站能自由访问彼此的文件，后果将不堪设想。\n\n### 另外谈 3 点小东西\n\n1. 为什么跨域访问要由客户端，也就是浏览器来管理，而不是服务器端呢？\n   由于这种情况服务器根本无从知晓：一台客户端跨域访问另一台客户端计算机（或者同一客户端上，一个网站读取另一网站储存在本地的 cookie），读取其文件和数据，然后利用获取的信息向服务器发送请求，服务器根本无从分辨发送请求的是谁。\n   因此跨域访问或同源政策的实施，必须只能在客户端进行管理。\n2. 跨域访问阻止的是什么？\n   跨域写（write）是被允许的，因此你的跨域访问信息会被对方接收到，真正被禁止的其实是跨域读（read）。因此跨域请求的响应信息、甚至响应码，我们都是收不到的，因为被浏览器屏蔽掉了。\n3. 有跨域读取被允许的现象吗\n   其实通过 HTML 的标签跨域载入以下资源（字体除外）是被允许的：图片、CSS 样式表、JS 文件。\n   这些文件是通过下载到本地再进行运行的。\n   延伸阅读：\n   [阮一峰：浏览器同源政策及其规避方法](http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)\n   [Same-origin policy - Wikipedia](https://en.wikipedia.org/wiki/Same-origin_policy#cite_note-2)\n   [Cross-Domain requests in Javascript | jvaneyck](https://jvaneyck.wordpress.com/2014/01/07/cross-domain-requests-in-javascript/)\n","n":0.108}}},{"i":7,"$":{"0":{"v":"Web 开发必学知识点 (原创翻译)","n":0.577},"1":{"v":"\n> 写于：2018-10-02\n\n![](/assets/images/2023-02-26-10-18-05.png)\n\n> StackExchange 上有一个关于 web 开发中需要注意的知识点的帖子非常火，已经有 2k 的点赞了，非常全也非常好，所以决定翻译出来供大家使用。\n> 原文链接：[What should every programmer know about web development?](https://softwareengineering.stackexchange.com/questions/46716/what-technical-details-should-a-programmer-of-a-web-application-consider-before)\n> 尽管大多数人对清单中所列都有所耳闻。但是个别的几条可能还没仔细了解过，或者没全弄明白，甚至没听过。\n\n### API 和用户体验：\n\n- 了解浏览器所兼容的标准并非完全一致，保证你的网站能兼容主流浏览器。起码在最新的[Gecko](https://en.wikipedia.org/wiki/Gecko_%28layout_engine%29)引擎（Firefox）、WebKit 引擎（Safari 以及个别移动端浏览器）、Chrome、IE 浏览器（非必须，可使用[“应用兼容性 VPC 镜像”](http://www.microsoft.com/Downloads/details.aspx?FamilyID=21eabb90-958f-4b64-b5f1-73d0a413c8ef&displaylang=en)测试）以及 Opera 中进行测试。还应该考虑在不同操作系统下，浏览器[渲染机制的不同性](http://www.browsershots.org/)。\n- 顾及网站的不同使用场景，而不仅仅顾及哪些主流浏览器：手机、读屏软件以及搜索引擎。举例来说，一些无障碍信息：[WAI](http://www.w3.org/WAI/)和[Section508](http://www.section508.gov/)，移动开发：[MobiForge](http://mobiforge.com/)。\n- 部署 Staging：如何部署网站更新而不影响用户访问。准备一个或多个测试或 staging 的环境用于架构、代码修改或者内容替换，另外应保证部署过程完全受控且不会带来任何问题。然后通过自动化的将经过测试的代码部署到生产环境中。需使用版本管理工具（git，Subversion 等）以及自动化构建工具（Ant, NAnt, etc.)等，来实现该功能。\n- 别把不友好的错误信息直接展示给用户。\n- 别把用户的邮箱地址以明文显示出来，防止用户被垃圾邮件骚扰。\n- 为用户的链接加上[`rel=nofollow`](https://en.wikipedia.org/wiki/Nofollow)属性，以避免垃圾网站的干扰。\n- 为[网站限制设置一些限制条件](http://www.codinghorror.com/blog/archives/001228.html)，这也属于安全范畴。\n- 学习如何实现[渐进式增强 Progressive Enhancement](http://www.codinghorror.com/blog/archives/001228.html)。\n- POST 请求成功后应进行页面跳转，以避免刷新页面重复提交请求。\n- 重点关注无障碍 Accessibility，这永远是个好点子，个别情况也属于[法律要求](http://www.section508.gov/)。可以参考[WAI_ARIA](http://www.w3.org/WAI/intro/aria)和[WCAG 2](http://www.w3.org/TR/WCAG20/)的相关资源。\n- 学习[别让我考虑怎么做](http://www.sensible.com/dmmt.html)\n\n### 安全相关\n\n- 需要慢慢消化吸收[OWASP 开发指南](http://www.owasp.org/index.php/Category:OWASP_Guide_Project)，这篇文章所涵盖的 web 安全相关知识非常全面。\n- 学习注入攻击以及如何防范，尤其是[SQL 注入](http://en.wikipedia.org/wiki/SQL_injection)。\n- 对于用户输入的内容，以及任何通过请求发送的内容（尤其是含有 cookie 和隐式表单数据的请求）要保持警惕。\n- 使用“盐”对密码进行哈希加密，对于不同的数据条目使用不同的“盐”，以避免彩虹攻击(rainbow attacks)。使用慢哈希算法储存密码，比如 bcrypt（时间验证）或 scrypt（更强大，同时也较新）（[如果安全的保存密码](http://codahale.com/how-to-safely-store-a-password/)）。避免直接使用 MD5 或 SHA 等类型。\n- [不要使用自创的身份验证系统](https://stackoverflow.com/questions/1581610/how-can-i-store-my-users-passwords-safely/1581919#1581919)。尤其在细节上和无法测试等方面很容易出错，甚至只有当你的网站被黑客攻击以后才发现有漏洞。\n- 学习处理信用卡的一些规则。（[同时也可以了解一下这个问题](https://stackoverflow.com/questions/51094/payment-processors-what-do-i-need-to-know-if-i-want-to-accept-credit-cards-on-m)）\n- 对于用户登陆页面，以及任何需要输入敏感信息（比如信用卡信息）的页面，使用 SSL/HTTPS。[Let's Encrypt](https://letsencrypt.org/)可以提供免费的证书。\n- 避免[session 劫持](https://en.wikipedia.org/wiki/Session_hijacking#Prevention)。\n- 避免跨站脚本攻击(XSS)。\n- 避免跨站请求伪造攻击(CSRF)。\n- 避免点击劫持([Clickjacking](https://en.wikipedia.org/wiki/Clickjacking))。\n- 保持你的系统里的所有软件为最新版。\n- 采取防范措施，保证数据库的连接是安全的。\n- 了解最新的攻击手段以及危及你的网站的技术漏洞。\n- 学习[Google 浏览器安全手册](https://code.google.com/archive/p/browsersec/)。\n- 学习[网络应用黑客手册](http://amzn.com/0470170778)。\n- 考虑使用[最小特权原则](https://en.wikipedia.org/wiki/Principle_of_least_privilege)。尝试使用[非 root 账户](https://security.stackexchange.com/questions/47576/do-simple-linux-servers-really-need-a-non-root-user-for-security-reasons)运行你的 app 服务器。（这是一个[tomcat 的示例](http://tomcat.apache.org/tomcat-8.0-doc/security-howto.html#Non-Tomcat_settings)）\n- 在所有由用户提供的含有`target=\"_blank\"`的链接中，加上`res=\"noopener noreferrer\"`，以避免目标页面中的 JavaScript 对页面进行重定向，比如重定向至一个伪登陆页面，[更多信息](https://dev.to/phishing)。\n- 可以使用[验证内容安全政策(strict Content Security Policy)](https://csp.withgoogle.com/docs/index.html)。\n\n### 性能相关\n\n- 必要时使用缓存，理解并使用[HTTP 缓存特性](http://www.mnot.net/cache_docs/)以及[HTML5 Manifest](http://www.w3.org/TR/2011/WD-html5-20110525/offline.html)。\n- 对图片进行优化：不要用 20KB 的图片作为平铺背景。\n- 学习如何使用[gzip 等技术](http://developer.yahoo.com/performance/rules.html#gzip)压缩内容。\n- 将多个样式表或脚本文件进行合并，以减少浏览器连接/请求的次数，同时设置 gzip 对重复的文件进行压缩。\n- 浏览一下[雅虎出色性能](http://developer.yahoo.com/performance/)网站，里面有很多不错的文章，包括如何提升前端性能以及如何使用[YSlow](http://developer.yahoo.com/yslow/)工具（需要 Firefox, Safari, Chrome 或 Opera）。另外，[Google 网页速度](https://developers.google.com/speed/docs/best-practices/rules_intro)（同[浏览器插件一同使用](https://developers.google.com/speed/pagespeed/insights_extensions)）是另一款性能测试工具，它还能对你网站的图片进行优化。\n- 使用[SVI sprite 技术]()用于小的彼此相关的图片，比如：工具栏。SVG 上色有些困难，可以看看[这篇文章]()。\n- 高访问量的网站应考虑拆分组件并部署在不同的服务器上，比如：\n- 静态资源（如：图片、CSS、JS 脚本以及其他不需要 cookie 权鉴才能访问的文件）应部署在一个单独的[不使用 cookie](http://blog.stackoverflow.com/2009/08/a-few-speed-improvements/)的服务器上，这样做是因为在向网站发送的时候，无论是主域名还是其子域名请求都会附带 cookie。这里有个方法是使用 CDN（内容分发网络），但是需注意 CDN 请求可能会失败，这里可以通过使用备用 CDN 或者直接提供本地备份。\n- 减少浏览器渲染页面所需要发送 HTTP 请求的总次数。\n- 选择一个模板引擎并使用任务管理程序 gulp 或 grunt 进行渲染/预渲染。\n- 保证你网站根目录下有一个`favicon.ico`文件。因为即使 HTML 未引入该文件，浏览器还是会自动请求该文件。如果没有`/favicon.ico`文件则会导致大量 404 报错，占用你服务器的带宽。\n\n### SEO（搜索引擎优化）\n\n- 使用搜索引擎友好的 URL，例如：用 `example.com/pages/45-article-title` 而非 `example.com/index.php?page=45`\n- 如果使用`#`用于动态内容变化，那么把`#`变为`#!`然后\n- 不要使用诸如[\"请点这儿\"](https://ux.stackexchange.com/questions/12100/why-shouldnt-we-use-the-word-here-in-a-textlink)的链接，这样做就是在是浪费 SEO 的机会，这同时也为使用读屏软件的用户带来一些困难。\n- 创建一个[XML 网站地图](http://www.sitemaps.org/)，最好将其放在默认位置`/sitemap.xml`。\n- 当有多个 URL 指向同一个内容时使用[<link rel=\"canonical\" ... />](http://googlewebmastercentral.blogspot.com/2009/02/specify-your-canonical.html)，该问题也可以通过[Google 网络管理员工具](http://www.google.com/webmasters/)进行处理。\n- 使用[Google 网络管理员工具](http://www.google.com/webmasters/)和[Bing 网络管理员工具](http://www.bing.com/toolbox/webmaster)。\n- 从网站上线开始就安装使用[Google Analytics](http://www.google.com/analytics/)（或者其他开源分析工具如[Piwik](http://piwik.org/)）。\n- 了解[robots.txt](https://en.wikipedia.org/wiki/Robots_exclusion_standard)的作用以及搜索引擎爬虫的工作方式。\n- 将`www.example.com`的请求重定向（用`301 Moved Permanently`）至`example.com`（或反过来）以避免两个网址同时占用 Google 排名。\n- 了解个别爬虫的工作还是有一定问题的。\n- 如果你有一些非文本的内容需要在 Google’s sitemap 中，比如视频。[Tim Farley 回答](https://stackoverflow.com/questions/72394/what-should-a-developer-know-before-building-a-public-web-site#167608)或许可以让你看到很多有价值的东西。\n\n![](/assets/images/2023-02-26-10-18-18.png)\n\n### 技术相关\n\n- 学习[HTTP 协议](http://www.ietf.org/rfc/rfc2616.txt)，以及 GET、POST、session、cookie 以及“无状态”等概念。\n- 让你的[XHTML](http://www.w3.org/TR/xhtml1/)/[HTML](http://www.w3.org/TR/REC-html40/)和[CSS](http://www.w3.org/TR/CSS2/)符合[W3C 规范](http://www.w3.org/TR/)，并确认它们都是[合格的](http://validator.w3.org/)。我们最终的目标是避免浏览器的怪异模式（quiks mode），这也将使得网站对于非标准浏览器（如读屏软件和移动设备）更加友好。\n- 学习浏览器是如何处理 JavaScript 的。\n- 学习浏览器是如何加载 JavaScript、CSS 样式表和其他资源的，并了解其对视觉上的影响。一般认为[脚本应该放在页面的底部](https://developer.yahoo.com/blogs/ydn/high-performance-sites-rule-6-move-scripts-bottom-7200.html)，但分析程序或 HTML5 填充程序属于例外。\n- 学习 JavaScript 的沙箱的工作原理，尤其是当你想使用 iframe 时。\n- 注意 JavaScript 可以被禁用或者将要被禁用，而 AJAX 将成为插件，而非必须。尽管人们都普遍使用它们，但请注意[NoScript](http://noscript.net/)已经越来越火，移动设备工作方式有所不同，同时 Google 在收录网站的时候并不会运行你的 JavaScript 代码。\n- 学习[301 和 302 重定向状态码之间的区别](http://www.bigoakinc.com/blog/when-to-use-a-301-vs-302-redirect/)（这也是一个 SEO 问题）。\n- 尽可能的了解你将要的部署平台。\n- 考虑使用[“重置样式表”](https://stackoverflow.com/questions/11578819/css-reset-what-exactly-does-it-do)或[normalize.css](http://necolas.github.com/normalize.css/)。\n- 考虑使用 JavaScript 框架（例如[jQuery]()，[MooTools](http://mootools.net/)，[Prototype](http://www.prototypejs.org/)，[Dojo](http://dojotoolkit.org/)或[YUI 3](http://developer.yahoo.com/yui/3/)），它们会很好的兼容于不同的浏览器。\n- 把视觉效果和 JS 框架合在一起讨论，考虑使用一个 Service，如：[Google Libraries API](http://developers.google.com/speed/libraries/devguide) 来装载框架，这样可以让浏览器可能早就把这个 JS 框架已经 cache 了而不需要再从你的网站上下载了。\n- 不要重新造轮子，在开始工作之前找找有没有类似的组件或示例。有 99％的可能性某人已经完成并发布了 OSS 版本的代码。\n- 另外，在了解你的需求之前，一开始不要恨不得把 20 个库都用上。尤其是客户端，保持轻量级、快速和灵活性总是更重要的。\n\n### 漏洞修复\n\n- 明白你将花费 20％的时间写编码，80％的时间维护，所以写代码的时候要谨慎。\n- 设计一个好的错误报告机制。\n- 设计一个入口可以让用户与你取得联系，向你提出建议和批评。\n- 写项目文档，这样可以让维护你的软件和系统的人更容易上手。\n- 常备份（也确保这些备份有效）！制定备份恢复策略，而不仅仅是备份策略。\n- 使用版本控制工具来备份文件，例如：[Subversion](http://subversion.apache.org/)，[Mercurial](http://mercurial.selenic.com/)或[Git](http://git-scm.org/)。\n- 别忘了做验收测试。可以使用 Selenium 这样的框架。如需要进行自动化测试，可以使用持续集成工具，例如[Jenkins](http://jenkins-ci.org/)。\n- 使用[log4j](http://logging.apache.org/log4j/)，[log4net](http://logging.apache.org/log4net/)或[log4r](http://log4r.rubyforge.org/)等框架，以确保你有足够的日志。如果出了问题，这是可以让你快速找到问题的方式。\n- 记录日志时，确保你记录了你捕获了处理和未处理异常。报告和分析日志可以让你知道你网站的问题。\n\n#### 其他\n\n- 实施服务器端和客户端监控和分析（应该是主动的而不是被动的）。\n- 使用 UserVoice 和 Intercom（或其他类似的工具）等服务，可以让你和用户保持紧密的联系。\n- 遵从[Vincent Driessen](http://nvie.com/about/)的[Git 分支模型](http://nvie.com/posts/a-successful-git-branching-model/)\n  这里有多的东西被省略了，不是因为它们没用，而是因为它们要么太细、超出范围，要么对于想要了解自己想知道的知识的人它们有点太宽泛了。文章可能有遗漏或者有错误，所以请随意编辑这篇帖子。\n","n":0.062}}},{"i":8,"$":{"0":{"v":"管理好我的注意力","n":1},"1":{"v":"\n> 写于：2018-05-20\n\n> “注意力才是你最宝贵的财富”\n\n《通往财富自由之路》一书提出过一个概念\n\n> “注意力才是你最宝贵的财富”。\n\n有效的引导和管理你的注意力，可以让自己的工作和生活更加有效率，提高了效率，就有更多的时间来投入到更有意义的上事情去了。\n\n最近在武志红《心理学课》专栏里也读到一篇关于注意力的文章，他教读者如何用注意力扫描身体（其实就是佛教的静坐）也叫坐享，通过运用注意力扫描身体练习注意力，通过这种练习可以很容易让自己的意识放松，有时甚至可以利用中午短短五分钟小睡一下。\n\n他还提到，你越是努力控制念头，由于注意力的注入，念头会受到滋养变得越来越强，但是，如何你通过调整注意力，由于得不到滋养念头反而会弱下来。\n\n_两大工具帮助你管理注意力_\n\n1. 清单工具，我用过的清单工具很少，现在在用的叫做“滴答清单”，可以调整不同人物的优先级，专注于完成高优先级的事情。\n2. 番茄工作法，用番茄时间让自己保持专注，买了《番茄工作法图解》，还在学习中。\n\n关于滴答清单这款软件，我是在 Youtube 上科技达人 MKBHD 的“What's on my phone”节目知道的，软件英文名叫“Tick Tock\"，后来一查发现原来是国产软件，就叫“滴答清单”。上手使用感觉很不错，支持全平台而且操作简单、界面清爽。只要有最新的任务，为了避免遗忘，我都会通过手机和电脑第一时间加入到清单待办里。\n\n我认为清单类软件最大的好处就是任务记录和优先级排序，可以随时记录我的任务，另外让我了解当前什么最重要，什么任务完成不了也无所谓。\n\n关于番茄工作法其实我个人觉得还比较受用，在日常工作中我会用电脑上的番茄时钟的软件（Mac 上用的 iTimer 软件）来计时和提醒，以 25 分钟作为一个时间段。\n\n其实工作也需要仪式感，每次计时开始，我就会立马让自己进入状态，而不是拖延和犹豫，我希望持续深入学习如何把番茄工作法用好。\n\n我一直有这样一个毛病，就是在上班期间很容易被办公室里的闲聊打扰，自己也尝试过专注，但是一直很无奈。通过用滴答清单明确当前重要任务，以及通过番茄钟计时，让我更加容易的投入到手头的任务中去，而不是任凭自己的注意力四处游荡，现在我容易被打扰的毛病改善了许多。\n\n管理好你自己的注意力其实是非常宝贵的，我们的时间有限，所以一定要把它用到最关键的地方去，希望本文能对你有所帮助。\n","n":0.229}}},{"i":9,"$":{"0":{"v":"我的双拼学习经历","n":1},"1":{"v":"\n> 写于：2018-04-14\n\n我学习双拼输入法是从 2017 年 10 月份开始的，到现在差不多 6 个月，现在的打字速度已经飞快。\n\n其实最初用全拼输入法已经觉得自己打字速度很快了，但是跟现在的打字速度相比，还是慢了一些。\n\n在最初用全拼的时候，我也思考了如何进一步提高自己的打字速度，最初选择了五笔。\n\n我学习五笔完全是不是靠自己死记硬背五笔字根，而是靠自己实践。当时每天都会用五笔敲一段文字，最开始相当的艰难，半小时可能才能敲出几十个字来，但是一直坚持坚持，通过自己三个月的努力，让自己对于五笔基本的键位和字根所在的键位记住了，但是时不时的会有一些字实在是想不起来的，需要看一下字根表。\n\n实践果然是最好的老师，自己也从最初的半天敲出一点点，慢慢的提高了自己的打字速度。经过半年的学习下来基本可以不看字根表打字了，但是打字速度还是慢的不行。后来在无意中看到了李笑来写的一篇文章，后来就毅然决定学习双拼。\n\n双拼输入法的上手的速度的确很快。最开始会有一段阵痛期，但是我学习双拼的过程几乎没有感觉到什么痛苦。\n\n李笑来曾经提出学好英语的诀窍就是用，你只有不断的使用它，在用的过程中你的能力就会不断得到锻炼。\n\n我觉得学习输入法的办法也是用，不断的用，最开始用的不好也没有关系，每天用一会儿，或者干脆一直用，打字慢点就慢点。\n\n于是最开始我并没有死记硬背键位分布表，而是把键位写在一张小纸片上，贴在屏幕下方，不知道的时候看一眼，这样日积月累的，不出一个月已经基本可以正常打字了。再继续打下去，打字速度的提升也是非常可观的。\n\n我现在在手机上也使用双拼输入法，自己的打字速度也快了很多，因为平时需要按很多次键盘才能输出的字，现在只需要敲击寥寥几次就可以输出。\n这简直就是开挂了，或者简直就是 bug 输入嘛。\n\n我的目标就是让自己的键盘输入的速度能够跟上自己的思考速度，让自己的能够更加顺畅的输入自己的思考的东西。天下武功，唯快不破，你的输入速度快，无形当中给你带来了很多优势，并且是别人根本无法察觉到的，\n\n输入法这个东西我觉得是可以带来复利效应的，也是投入努力就立即可以看到成效的事情，对于这样的事情遇到了就要积极去做，不是吗？\n","n":0.316}}},{"i":10,"$":{"0":{"v":"JavaScript 中{}+{}是多少？ (原创翻译)","n":0.577},"1":{"v":"\n> 写于：2018-04-10\n\n![](/assets/images/2023-02-26-10-15-13.png)\n\n> 原文：[What is {} + {} in JavaScript?](http://2ality.com/2012/01/object-plus-object.html) > ![title image](https://ws2.sinaimg.cn/large/006tKfTcly1g0k77picxdj30m808cglu.jpg)\n> Gary Bernhardt 最近在他的“[Wat](https://www.destroyallsoftware.com/talks/wat)”演讲中，指出了一个 JavaScript 语言有趣而又奇怪之处：当你把对象和数组相加时，会得到意想不到的结果。 本文将解释逐一进行解释。\n> JavaScript 的加法规则其实很简单：你只能使用数字和字符串进行相加，而所有其他数据类型都将被转换为其中一种。为了理解类型转换的原理，我们首先需要了解一些基础知识。\n> 注意：本文中提到的章节（比如第 9.1 节）都出自 ECMA-262 语言规范（ECMAScript 5.1）。\n> 让我们先快速的复习一下：JavaScript 中有两种类型的值：原始值（primitive）和对象（object）[1]。 原始值包括：`undefined`、`null`、`boolean`、`number`和`string`。其他所有类型的值都是对象，如：`array`和`function`等。\n\n## 1.类型转换\n\n加法运算符会触发三种类型转换：它将值转换为原始值、`number`或`string`。\n\n### 1.1. 用 ToPrimitive() 将值转换为原始值\n\n`ToPrimitive()`的使用语法如下：\n\n```js\nToPrimitive(input, PreferredType?)\n```\n\n可选参数`PreferredType`可以是`Number`或`String`类型。它仅表示期望的转换类型，而最终结果可以是任何原始类型值。假如`PreferredType`是`Number`，则将通过以下步骤完成`input`值的类型转换（第 9.1 节）：\n\n1. 如`input`是原始类型值，则按原样返回。\n2. 如并非原始类型值而是对象，则调用`obj.valueOf()`。如结果为原始类型值，则直接返回该值。\n3. 如返回的并非原始类型值，则调用`obj.toString()`。如结果为原始类型值，则直接返回该值。\n4. 如返回的并非原始类型值，则抛出`TypeError`错误。\n   如`PreferredType`是`String`，则将步骤 2 和步骤 3 对调。如并未给出`PreferredType`，对于`Date`类型实例该值默认为`String`，而对于所有其他值该值默认为`Number`。\n\n### 1.2. 用 ToNumber() 将值转换为数字\n\n下表解释了`ToNumber()`如何将原始类型值转换为数字的（第 9.3 节）：\n参数|结果\n---|---\n`undefined`|`NaN`\n`null`|`+0`\nboolean|`true`转换为 1，`false`转换为`+0`\nnumber|不用转换\nstring|转换字符串中的数字，例如：将`\"324\"`转换为`324`\n通过调用对象`obj`的`ToPrimitive(obj，Number)`方法，对于得到的（原始类型的）结果调用`ToNumber()`将其转换为数字。\n1.3. 用 ToString() 将值转换为字符串\n下表解释了 ToString（）如何将原始类型值转换为字符串（第 9.8 节）：\n参数|结果\n---|---\n`undefined`|`undefined`\n`null`|`null`\nboolean|`\"true\"`或`\"false\"`\nnumber|原数字的字符串书写方式，比如：`\"1.765\"`\nstring|不用转换\n通过调用对象`obj`的`ToPrimitive(obj，String)`方法，对于得到的（原始类型的）结果调用`ToString()`将其转换为字符串。\n\n### 1.4. 实践\n\n通过以下对象，你将看到引擎内部的转换过程：\n\n```js\nvar obj = {\n\tvalueOf: function () {\n\t\tconsole.log('valueOf');\n\t\treturn {}; // not a primitive\n\t},\n\ttoString: function () {\n\t\tconsole.log('toString');\n\t\treturn {}; // not a primitive\n\t}\n};\n```\n\n当把`Number`作为一个普通函数（而非构造函数）调用时,会在引擎内部调用`ToNumber()`方法:\n\n```js\n  > Number(obj)\n  valueOf\n  toString\n  TypeError: Cannot convert object to primitive value\n```\n\n## 2.加法\n\n对于如下加法运算：\n\n```js\nvalue1 + value2;\n```\n\n执行该表达式时，内部运算逻辑如下（第 11.6.1 节）：\n\n1. 将两个参加运算的值转换为原始类型值（以下是数学表示法，而非 JavaScript 代码）：\n\n```\n  prim1 := ToPrimitive(value1)\n  prim2 := ToPrimitive(value2)\n```\n\n此处省略了`PreferredType`，因此对于 Date 类型的值该值默认为`String`,其他类型的值该值默认为`Number`。\n\n2. 如果 prim1 或 prim2 有一个是字符串，则将另一个也转换为字符串，最终返回字符串拼接后的结果。\n3. 如果都不是字符串，则将 prim1 和 prim2 都转换为数字，并返回他们之和。\n\n### 2.1. 符合预期结果\n\n当您将两个数组相加时，结果符合我们的预期：\n\n```js\n  > [] + []\n  ''\n```\n\n将[]转换为原始类型值，首先会调用`valueOf()`方法，最终返回数组本身（this）：\n\n```js\n  > var arr = [];\n  > arr.valueOf() === arr\n  true\n```\n\n由于结果并非原始类型值，接下来将调用`toString()`方法，返回空字符串（原始类型值）。这样一来，`[]+[]`的结果，其实就是两个空字符串拼接的值。\n将数组和对象相加也符合我们的预期：\n\n```js\n  > [] + {}\n  '[object Object]'\n```\n\n说明：将空对象转换为字符串的结果如下：\n\n```js\n  > String({})\n  '[object Object]'\n```\n\n因此，上一个表达式的结果就应该是`\"\"`和`\"[object Object]\"`的字符串拼接的值。\n更多将对象转换为原始类型值的例子：\n\n```js\n  > 5 + new Number(7)\n  12\n  > 6 + { valueOf: function () { return 2 } }\n  8\n  > \"abc\" + { toString: function () { return \"def\" } }\n  'abcdef'\n```\n\n### 2.2. 非预期结果\n\n如果`+`的头一个运算值是空对象字面量（在 Firefox 控制台输出的结果）：\n\n```js\n  > {} + {}\n  NaN\n```\n\n这是怎么回事儿？这是由于 JavaScript 将第一个`{}`解析为空代码块并忽略了。因此，通过计算`+ {}`（加号和第二个`{}`）最终得到`NaN`。 这里的加号并非二元加法运算符，而是一元运算符前缀，它将其运算值转换为数字，其方法与`Number()`相同，例如：\n\n```js\n  > +\"3.65\"\n  3.65\n```\n\n以下表达式的结果都相同：\n\n```js\n+{};\nNumber({});\nNumber({}.toString()); // {}.valueOf() 并非原始类型值\nNumber('[object Object]');\nNaN;\n```\n\n为什么第一个`{}`被解析为代码块？ 原因是整个输入内容被解析成了一段语句，而以开头花括号的语句会被解析为代码块。 你也可以强制把输入内容解析为表达式，从而来修正计算结果：\n\n```js\n  > ({} + {})\n  '[object Object][object Object]'\n```\n\n另外,函数或方法的参数也会被解析为表达式:\n\n```js\n  > console.log({} + {})\n  [object Object][object Object]\n```\n\n经过前面的讲解，见到下面的计算结果，你应该不会感到惊讶：\n\n```js\n  > {} + []\n  0\n```\n\n同样，上述语句也被解析为代码块和`+ []`。以下表达式的结果都相同：\n\n```js\n+[];\nNumber([]);\nNumber([].toString()); // [].valueOf() 并非原始类型值\nNumber('');\n0;\n```\n\n有趣的是，Node.js 的`REPL`在解析类似的输入时，与 Firefox 和 Chrome(同 Node.js 一样使用 V8 引擎)的解析结果不同。以下输入被解析为表达式，结果符合我们预期：\n\n```js\n  > {} + {}\n  '[object Object][object Object]'\n  > {} + []\n  '[object Object]'\n```\n\n它好处在于，其结果更像是将输入作为`console.log()`参数时所得到的结果。而非将输入用在程序语句中所得到的结果。\n\n## 3.总结\n\n大多数情况下，理解 JavaScript 中`+`的工作原理并不难：您只能将数字或字符串相加。 对象将被转换为字符串（如另一运算值是字符串的话）或数字（如另一运算值并非字符串）。 如需合并数组，则需要使用以下方法：\n\n```js\n  > [1, 2].concat([3, 4])\n  [ 1, 2, 3, 4 ]\n```\n\nJavaScript 中没有内置的方法“连接”（合并）对象。 你需要使用像[Underscore](http://documentcloud.github.com/underscore/)这样的库：\n\n```js\n  > var o1 = {eeny:1, meeny:2};\n  > var o2 = {miny:3, moe: 4};\n  > _.extend(o1, o2)\n  { eeny: 1,\n    meeny: 2,\n    miny: 3,\n    moe: 4 }\n```\n\n注意：相较`Array.prototype.concat()`，`extend()`修改的是第一个参数：\n\n```js\n  > o1\n  { eeny: 1,\n    meeny: 2,\n    miny: 3,\n    moe: 4 }\n  > o2\n  { miny: 3, moe: 4 }\n```\n\n如您还想了解更多关于运算符的知识，推荐阅读这篇文章“[JavaScript 中的假运算符重载](http://2ality.com/2011/12/fake-operator-overloading.html)”。\n\n## 4.索引\n\n1. [JavaScript 中的值：并非所有都是对象](http://2ality.com/2011/03/javascript-values-not-everything-is.html)\n","n":0.057}}},{"i":11,"$":{"0":{"v":"我的双屏显示器使用经历","n":1},"1":{"v":"\n> 写于：2018-03-28\n\n现代生活中我们与电脑接触的越来越多，甚至有些人在工作中跟电脑接触比接触人都多，邮件、任务分发、查阅通知都会用到电脑，它已经成为了我们最常用的工具之一。\n\n“工欲善其事，必先利其器”\n\n既然电脑就是一种工具，在一定程度上对它进行升级，将会带来工作/学习效率的提升。而电脑的显示器，作为我们与电脑之间的交互媒介之一，为我们打开了一扇通往虚拟世界的窗户，让我们在这个世界中遨游。\n\n我的双显使用经历\n其实我也不是一开始就意识到，增大显示面积后有多么重要。我最初是在 youtube 上看视频看到科技达人 Marques 在用双屏显示器，他用的是两个 31.5 寸的 4K 分辨率的显示屏（见下图）。\n\n原来显示器还可以这么用的！这就是当初对我的震撼。在网上搜索相关信息之后，基本确定了双屏/大屏对于提升工作效率是有所帮助的。就这样在我心里种了草，在升级显示屏的路上中毒越来越深。\n\n由于那段时间长期出差，我购买了自己的第一块移动屏幕：ASUS 便携式显示器 MB169。\n\n我在使用过第二块屏幕之后，于是再也回不去用单屏显示器了，并且在升级显示器的这条路上越走越远。\n\n咸鱼买了一个 27 寸显示器，超便宜才 500 块。后来把这个显示屏淘汰到公司去用了（下面图中左边的显示器）\n\n再后来入手一台 38 寸 LG 38 寸曲面屏显示器 38WK95C。关于 LG 的 38 寸超宽曲面屏点开原文链接看视频评测。\n\n双显真的有用吗？\n记得李笑来在天天用英语的开课时说过，他就用两台 27 寸的屏幕，他发现用起来真的很爽，于是劝说朋友也去买，可是没有人听。于是他主动买了一堆显示器送给他的朋友，结果大家用了都觉得好。\n\n不知道你是否有这样的体验，用电脑时，来回在两个窗口之间来回切换，非常麻烦。\n\n增加一块屏幕，增大了有效屏幕面积，让你可以更加随意的使用屏幕，基本不用考虑最小化和切换窗口的问题了。\n\n随着屏幕面积的提升，因为不用为窗口的摆放发愁了，你做事情的效率也会有所提升。具体的使用场景可能有：\n\n1. 需要进行一些对比工作；\n2. 习惯于几个窗口同时使用，比如：看英文电子书的同时想查查词典，计算投资收益的同时想用用计算器，写文章的同时想用浏览器查查资料。\n\n在上述场景，如果是用双屏，会让人有种相当顺手的感觉。\n\n我用双屏显示器已经有一段时间了，再用单屏就会觉得很憋屈。这跟用惯了大屏手机，就用不惯小屏手机是同样的道理。\n\n在条件允许的情况下，你也可以适当升级一下显示屏，感受一下大屏/双屏带来的感受。\n","n":0.183}}}]}
